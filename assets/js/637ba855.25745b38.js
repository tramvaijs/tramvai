"use strict";(globalThis.webpackChunk=globalThis.webpackChunk||[]).push([[2343],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>m});var r=a(7294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},i=Object.keys(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var s=r.createContext({}),c=function(e){var t=r.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},u=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=c(a),m=n,h=p["".concat(s,".").concat(m)]||p[m]||d[m]||i;return a?r.createElement(h,o(o({ref:t},u),{},{components:a})):r.createElement(h,o({ref:t},u))}));function m(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,o=new Array(i);o[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:n,o[1]=l;for(var c=2;c<i;c++)o[c]=a[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,a)}p.displayName="MDXCreateElement"},5162:(e,t,a)=>{a.d(t,{Z:()=>o});var r=a(7294),n=a(6010);const i="tabItem_Ymn6";function o({children:e,hidden:t,className:a}){return r.createElement("div",{role:"tabpanel",className:(0,n.Z)(i,a),hidden:t},e)}},4866:(e,t,a)=>{a.d(t,{Z:()=>N});var r=a(7462),n=a(7294),i=a(6010),o=a(2466),l=a(6550),s=a(1980),c=a(7392),u=a(12);function d(e){return function(e){return n.Children.map(e,(e=>{if((0,n.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))}(e).map((({props:{value:e,label:t,attributes:a,default:r}})=>({value:e,label:t,attributes:a,default:r})))}function p(e){const{values:t,children:a}=e;return(0,n.useMemo)((()=>{const e=t??d(a);return function(e){const t=(0,c.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,a])}function m({value:e,tabValues:t}){return t.some((t=>t.value===e))}function h({queryString:e=!1,groupId:t}){const a=(0,l.k6)(),r=function({queryString:e=!1,groupId:t}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:e,groupId:t});return[(0,s._X)(r),(0,n.useCallback)((e=>{if(!r)return;const t=new URLSearchParams(a.location.search);t.set(r,e),a.replace({...a.location,search:t.toString()})}),[r,a])]}function y(e){const{defaultValue:t,queryString:a=!1,groupId:r}=e,i=p(e),[o,l]=(0,n.useState)((()=>function({defaultValue:e,tabValues:t}){if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!m({value:e,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const a=t.find((e=>e.default))??t[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:t,tabValues:i}))),[s,c]=h({queryString:a,groupId:r}),[d,y]=function({groupId:e}){const t=function(e){return e?`docusaurus.tab.${e}`:null}(e),[a,r]=(0,u.Nk)(t);return[a,(0,n.useCallback)((e=>{t&&r.set(e)}),[t,r])]}({groupId:r}),f=(()=>{const e=s??d;return m({value:e,tabValues:i})?e:null})();(0,n.useLayoutEffect)((()=>{f&&l(f)}),[f]);return{selectedValue:o,selectValue:(0,n.useCallback)((e=>{if(!m({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);l(e),c(e),y(e)}),[c,y,i]),tabValues:i}}var f=a(2389);const v="tabList__CuJ",b="tabItem_LNqP";function k({className:e,block:t,selectedValue:a,selectValue:l,tabValues:s}){const c=[],{blockElementScrollPositionUntilNextRender:u}=(0,o.o5)(),d=e=>{const t=e.currentTarget,r=c.indexOf(t),n=s[r].value;n!==a&&(u(t),l(n))},p=e=>{let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const a=c.indexOf(e.currentTarget)+1;t=c[a]??c[0];break}case"ArrowLeft":{const a=c.indexOf(e.currentTarget)-1;t=c[a]??c[c.length-1];break}}t?.focus()};return n.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":t},e)},s.map((({value:e,label:t,attributes:o})=>n.createElement("li",(0,r.Z)({role:"tab",tabIndex:a===e?0:-1,"aria-selected":a===e,key:e,ref:e=>c.push(e),onKeyDown:p,onClick:d},o,{className:(0,i.Z)("tabs__item",b,o?.className,{"tabs__item--active":a===e})}),t??e))))}function g({lazy:e,children:t,selectedValue:a}){if(t=Array.isArray(t)?t:[t],e){const e=t.find((e=>e.props.value===a));return e?(0,n.cloneElement)(e,{className:"margin-top--md"}):null}return n.createElement("div",{className:"margin-top--md"},t.map(((e,t)=>(0,n.cloneElement)(e,{key:t,hidden:e.props.value!==a}))))}function w(e){const t=y(e);return n.createElement("div",{className:(0,i.Z)("tabs-container",v)},n.createElement(k,(0,r.Z)({},e,t)),n.createElement(g,(0,r.Z)({},e,t)))}function N(e){const t=(0,f.Z)();return n.createElement(w,(0,r.Z)({key:String(t)},e))}},7637:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>u,contentTitle:()=>s,default:()=>m,frontMatter:()=>l,metadata:()=>c,toc:()=>d});var r=a(7462),n=(a(7294),a(3905)),i=a(4866),o=a(5162);const l={id:"hydration",title:"Hydration"},s=void 0,c={unversionedId:"features/rendering/hydration",id:"features/rendering/hydration",title:"Hydration",description:"Explanation from React documentation:",source:"@site/tmp-docs/03-features/010-rendering/03-hydration.md",sourceDirName:"03-features/010-rendering",slug:"/features/rendering/hydration",permalink:"/docs/features/rendering/hydration",draft:!1,editUrl:"https://github.com/tramvaijs/tramvai/-/edit/master/docs/tmp-docs/03-features/010-rendering/03-hydration.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{id:"hydration",title:"Hydration"},sidebar:"sidebar",previous:{title:"Page Render Mode",permalink:"/docs/features/rendering/page-render-mode"},next:{title:"Static-Site Generation",permalink:"/docs/features/rendering/ssg"}},u={},d=[{value:"Selective Hydration",id:"selective-hydration",level:2},{value:"Explanation",id:"explanation",level:3},{value:"Usage",id:"usage",level:3},{value:"Drawbacks",id:"drawbacks",level:3},{value:"Lazy Hydration",id:"lazy-hydration",level:2},{value:"Explanation",id:"explanation-1",level:3},{value:"More about lazy hydration",id:"more-about-lazy-hydration",level:4},{value:"Installation",id:"installation",level:3},{value:"Usage",id:"usage-1",level:3},{value:"Default mode",id:"default-mode",level:4},{value:"Customize wrapper",id:"customize-wrapper",level:4},{value:"Configuring IntersectionObserver",id:"configuring-intersectionobserver",level:4},{value:"Passing custom observer",id:"passing-custom-observer",level:4},{value:"Server cache",id:"server-cache",level:4},{value:"Cache keys",id:"cache-keys",level:5}],p={toc:d};function m({components:e,...t}){return(0,n.kt)("wrapper",(0,r.Z)({},p,t,{components:e,mdxType:"MDXLayout"}),(0,n.kt)("p",null,"Explanation from ",(0,n.kt)("a",{parentName:"p",href:"https://beta.reactjs.org/reference/react-dom/hydrate#hydrating-server-rendered-html"},"React documentation"),":"),(0,n.kt)("blockquote",null,(0,n.kt)("p",{parentName:"blockquote"},"In React, \u201chydration\u201d is how React \u201cattaches\u201d to existing HTML that was already rendered by React in a server environment. During hydration, React will attempt to attach event listeners to the existing markup and take over rendering the app on the client.")),(0,n.kt)("p",null,(0,n.kt)("inlineCode",{parentName:"p"},"tramvai")," provides full React 18 support and will automatically use ",(0,n.kt)("a",{parentName:"p",href:"https://beta.reactjs.org/reference/react-dom/client/hydrateRoot"},(0,n.kt)("inlineCode",{parentName:"a"},"hydrateRoot")," API")," at client-side, for older React versions ",(0,n.kt)("a",{parentName:"p",href:"https://beta.reactjs.org/reference/react-dom/hydrate"},(0,n.kt)("inlineCode",{parentName:"a"},"hydrate")," method")," will be used."),(0,n.kt)("p",null,"Hydration is not simple process and usually a one ",(0,n.kt)("a",{parentName:"p",href:"https://web.dev/optimize-long-tasks/"},"long heavy task"),", which can significantly delay the ",(0,n.kt)("a",{parentName:"p",href:"https://web.dev/i18n/en/tti/"},"time to interactivity")," of our application. There is a few optimisations which can improve hydration speed:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#selective-hydration"},"Selective Hydration")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"#lazy-hydration"},"Lazy Hydration"))),(0,n.kt)("h2",{id:"selective-hydration"},"Selective Hydration"),(0,n.kt)("h3",{id:"explanation"},"Explanation"),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://www.patterns.dev/posts/react-selective-hydration/"},"Selective Hydration")," - it is result of new React ",(0,n.kt)("a",{parentName:"p",href:"https://beta.reactjs.org/blog/2022/03/29/react-v18#what-is-concurrent-react"},"Concurrent Features"),", when hydration and rendering tasks splitted in small pieces of work."),(0,n.kt)("h3",{id:"usage"},"Usage"),(0,n.kt)("p",null,"Selective hydration can be activated by a few options:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://beta.reactjs.org/reference/react/Suspense"},(0,n.kt)("inlineCode",{parentName:"a"},"Suspense"))," wrapper around some heavy component - concurrent rendering will be used only for this component subtree"),(0,n.kt)("li",{parentName:"ul"},"Run ",(0,n.kt)("inlineCode",{parentName:"li"},"hydrateRoot")," inside ",(0,n.kt)("a",{parentName:"li",href:"https://beta.reactjs.org/reference/react/startTransition"},(0,n.kt)("inlineCode",{parentName:"a"},"startTransition"))," - concurrent rendering will be used for all application tree")),(0,n.kt)("p",null,(0,n.kt)("inlineCode",{parentName:"p"},"tramvai")," out-of-the-box will wrap ",(0,n.kt)("inlineCode",{parentName:"p"},"hydrateRoot")," in ",(0,n.kt)("inlineCode",{parentName:"p"},"startTransition"),", and selective hydration will be available automatically for all ",(0,n.kt)("inlineCode",{parentName:"p"},"tramvai")," applications with React >= 18 version!"),(0,n.kt)("h3",{id:"drawbacks"},"Drawbacks"),(0,n.kt)("p",null,"Selective hydration is not free:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"full hydration will be delayed because of more async tasks overhead"),(0,n.kt)("li",{parentName:"ul"},"if user interacts with page, React will swich to regular heavy hydration for faster response")),(0,n.kt)("p",null,"Because of that, we recommend to wrap all significant blocks of your application in ",(0,n.kt)("inlineCode",{parentName:"p"},"Suspense"),", because of this benefits:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"after user interaction, React will switch to regular hydration ",(0,n.kt)("strong",{parentName:"li"},"only for this block subtree")),(0,n.kt)("li",{parentName:"ul"},"if this block fails while server rendering, React will render ",(0,n.kt)("inlineCode",{parentName:"li"},"fallback")," and another page content will be rendered as usual (otherwise full page rendering will be failed)")),(0,n.kt)("h2",{id:"lazy-hydration"},"Lazy Hydration"),(0,n.kt)("h3",{id:"explanation-1"},"Explanation"),(0,n.kt)("p",null,(0,n.kt)("inlineCode",{parentName:"p"},"tramvai")," provides ",(0,n.kt)("inlineCode",{parentName:"p"},"@tramvai/react-lazy-hydration-render")," - it is a small library to improve hydration performance in SSR apps. It is based on a lazy hydration approach."),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Small")," only 650 bytes (minified and gzipped)"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Improves TTI")," do not waste CPU on what the user does not see"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Customize.")," component activation mechanism can be changed")),(0,n.kt)("h4",{id:"more-about-lazy-hydration"},"More about lazy hydration"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/facebook/react/issues/10923#issuecomment-338715787"},"How it works (discussed in issue at react's github)")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=UxoX2faIgDQ&t=3372"},"About selective hydration on React Conf 2019")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://youtu.be/NythxcOI2Mw?t=2925"},"react render strategy"))),(0,n.kt)("h3",{id:"installation"},"Installation"),(0,n.kt)(i.Z,{groupId:"npm2yarn",mdxType:"Tabs"},(0,n.kt)(o.Z,{value:"npm",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-bash"},"npm install @tramvai/react-lazy-hydration-render\n"))),(0,n.kt)(o.Z,{value:"yarn",label:"Yarn",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-bash"},"yarn add @tramvai/react-lazy-hydration-render\n")))),(0,n.kt)("p",null,"This library is using IntersectionObserver API. if you need to support older browsers, you should install ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/w3c/IntersectionObserver/tree/master/polyfill"},"intersection-observer polyfill")," in order for it to work."),(0,n.kt)("h3",{id:"usage-1"},"Usage"),(0,n.kt)("h4",{id:"default-mode"},"Default mode"),(0,n.kt)("p",null,"Component is activated when user scrolls to it."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-tsx"},"import React from 'react';\nimport { LazyRender } from '@tramvai/react-lazy-hydration-render';\n\nconst HeavyHeader = () => <header>1</header>;\n\nexport const Header = () => (\n  <LazyRender>\n    <HeavyHeader />\n  </LazyRender>\n);\n")),(0,n.kt)("h4",{id:"customize-wrapper"},"Customize wrapper"),(0,n.kt)("p",null,"You can configure the wrapper component."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-tsx"},"import React from 'react';\nimport { LazyRender } from '@tramvai/react-lazy-hydration-render';\n\nconst HeavyHeader = () => <header>1</header>;\n\nexport const Header = () => (\n  <LazyRender wrapper=\"p\" wrapperProps={{ style: { margin: '10px' } }}>\n    <HeavyHeader />\n  </LazyRender>\n);\n")),(0,n.kt)("h4",{id:"configuring-intersectionobserver"},"Configuring IntersectionObserver"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-tsx"},"import React from 'react';\nimport { LazyRender, createUseObserverVisible } from '@tramvai/react-lazy-hydration-render';\n\nconst useObserverVisible = createUseObserverVisible({\n  rootMargin: '0px',\n  threshold: 1.0,\n});\n\nconst HeavyHeader = () => <header>1</header>;\n\nexport const Header = () => (\n  <LazyRender useObserver={useObserverVisible}>\n    <HeavyHeader />\n  </LazyRender>\n);\n")),(0,n.kt)("h4",{id:"passing-custom-observer"},"Passing custom observer"),(0,n.kt)("p",null,"Package supports changing a loading mechanics. For example, component could be activated on click."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-tsx"},"import React, { useEffect, useState } from 'react';\nimport { LazyRender } from '@tramvai/react-lazy-hydration-render';\n\nconst isServer = typeof window === 'undefined';\n\nconst useClickActivated = (ref) => {\n  const [isVisible, changeVisibility] = useState(isServer);\n\n  useEffect(() => {\n    if (!ref.current || isVisible) {\n      return;\n    }\n\n    ref.current.addEventListener('click', () => changeVisibility(true));\n  }, [ref]);\n\n  return isVisible;\n};\n\nconst HeavyHeader = () => <header>1</header>;\n\nexport const Header = () => (\n  <LazyRender useObserver={useClickActivated}>\n    <HeavyHeader />\n  </LazyRender>\n);\n")),(0,n.kt)("h4",{id:"server-cache"},"Server cache"),(0,n.kt)("p",null,"For maximum rendering performance on server-side, ",(0,n.kt)("inlineCode",{parentName:"p"},"LazyRender")," has ability to cache rendering result (HTML string), and reuse them for subsequent renders."),(0,n.kt)("p",null,"It is very useful for static blocks, but may not be practical for units with different levels of dynamics."),(0,n.kt)("p",null,"Example, how to enable server cache:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-tsx"},"import React from 'react';\n// can be any other cache library\nimport LRU from '@tinkoff/lru-cache-nano';\nimport { LazyRender } from '@tramvai/react-lazy-hydration-render';\n\nconst serverCache = new LRU({ max: 20, ttl: 60000 });\n\nconst HeavyHeader = () => <header>1</header>;\n\nexport const Header = () => (\n  <LazyRender\n    cacheEnabled={true}\n    cacheKey=\"header\"\n    serverCache={serverCache}\n  >\n    <HeavyHeader />\n  </LazyRender>\n);\n")),(0,n.kt)("h5",{id:"cache-keys"},"Cache keys"),(0,n.kt)("p",null,"If you have a limited set of dynamic options with low cardinality, just use them in ",(0,n.kt)("inlineCode",{parentName:"p"},"cacheKey")," property:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-tsx"},'export const Header = ({ isMobile }) => {\n  const cacheKey = isMobile ? "header:mobile" : "header:desktop";\n\n  return (\n    <LazyRender\n      cacheEnabled={true}\n      cacheKey={cacheKey}\n      serverCache={serverCache}\n    >\n      <HeavyHeader\n        isMobile={isMobile}\n      />\n    </LazyRender>\n  );\n};\n')))}m.isMDXComponent=!0}}]);