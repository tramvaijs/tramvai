"use strict";(globalThis.webpackChunk=globalThis.webpackChunk||[]).push([[9592],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>u});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=r.createContext({}),l=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,c=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),h=l(n),u=o,m=h["".concat(c,".").concat(u)]||h[u]||p[u]||a;return n?r.createElement(m,i(i({ref:t},d),{},{components:n})):r.createElement(m,i({ref:t},d))}));function u(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=h;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var l=2;l<a;l++)i[l]=n[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},5565:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var r=n(7462),o=(n(7294),n(3905));const a={id:"persistent-state",title:"How to manage persistent state?"},i=void 0,s={unversionedId:"how-to/persistent-state",id:"how-to/persistent-state",title:"How to manage persistent state?",description:"Tramvai is an isomorphic framework that operates seamlessly on both the server and client sides. One thing to keep in mind is correctly synchronize content between the server and client to prevent hydration errors, which can lead to page flickering or can break markup completely. This guide provides insights on how to avoid these situations.",source:"@site/tmp-docs/how-to/persistent-state.md",sourceDirName:"how-to",slug:"/how-to/persistent-state",permalink:"/docs/how-to/persistent-state",draft:!1,editUrl:"https://github.com/tramvaijs/tramvai/-/edit/master/docs/tmp-docs/how-to/persistent-state.md",tags:[],version:"current",frontMatter:{id:"persistent-state",title:"How to manage persistent state?"},sidebar:"sidebar",previous:{title:"How to measure SPA navigation?",permalink:"/docs/how-to/how-measure-navigation"},next:{title:"react-query-usage",permalink:"/docs/how-to/react-query-usage"}},c={},l=[{value:"Prevent hydration errors",id:"prevent-hydration-errors",level:2},{value:"Setting state after Client-Side Rendering",id:"setting-state-after-client-side-rendering",level:3},{value:"Setting state before the hydration",id:"setting-state-before-the-hydration",level:3},{value:"Synchronizing state between server and client using cookies",id:"synchronizing-state-between-server-and-client-using-cookies",level:3},{value:"Saving state",id:"saving-state",level:2}],d={toc:l};function p({components:e,...t}){return(0,o.kt)("wrapper",(0,r.Z)({},d,t,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Tramvai is an isomorphic framework that operates seamlessly on both the server and client sides. One thing to keep in mind is correctly synchronize content between the server and client to prevent ",(0,o.kt)("a",{parentName:"p",href:"https://react.dev/reference/react-dom/client/hydrateRoot#hydrating-server-rendered-html"},"hydration")," errors, which can lead to page flickering or can break markup completely. This guide provides insights on how to avoid these situations."),(0,o.kt)("h2",{id:"prevent-hydration-errors"},"Prevent hydration errors"),(0,o.kt)("p",null,"There are a few methods to synchronize state between server and client:"),(0,o.kt)("h3",{id:"setting-state-after-client-side-rendering"},"Setting state after Client-Side Rendering"),(0,o.kt)("p",null,"One approach is to set the local state after the client-side render, during the ",(0,o.kt)("a",{parentName:"p",href:"/docs/features/app-lifecycle#clear"},"clear")," stage. While this method allows you to synchronize the state post-render, it means that the initial render will display with default values, followed by a re-render once the state is updated. This can lead to a flicker as the application transitions from the default values to the synchronized state, but you can still can render skeletons during the first render."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"provide({\n  provide: commandLineListTokens.clear,\n  useFactory: ({ store }) => {\n    return function handleLocalState() {\n      if (typeof window === 'undefined') {\n        return;\n      }\n\n      try {\n        const localState = localStorage.getItem(key);\n\n        store.dispatch(setPageErrorEvent(localState));\n      } catch (error) {\n        // ...\n      }\n    };\n  },\n  deps: {\n    store: STORE_TOKEN,\n  },\n});\n")),(0,o.kt)("h3",{id:"setting-state-before-the-hydration"},"Setting state before the hydration"),(0,o.kt)("p",null,"If your component uses local data and is only rendered on the client side, you can initialize the state before reaching the ",(0,o.kt)("inlineCode",{parentName:"p"},"generatePage")," stage and hydration. This approach allows you to set the state earlier in the lifecycle, ensuring that the correct data is displayed from the first render, preventing any flicker or mismatch due to late updates."),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"Client Only component is component, which renders content only in the browser and renders ",(0,o.kt)("inlineCode",{parentName:"p"},"null")," or some loader/skeleton on the server.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"provide({\n  provide: commandLineListTokens.customerStart,\n  useFactory: ({ store }) => {\n    return function handleLocalState() {\n      if (typeof window === 'undefined') {\n        return;\n      }\n\n      try {\n        const localState = localStorage.getItem(key);\n\n        store.dispatch(setPageErrorEvent(localState));\n      } catch (error) {\n        // ...\n      }\n    };\n  },\n  deps: {\n    store: STORE_TOKEN,\n  },\n});\n")),(0,o.kt)("h3",{id:"synchronizing-state-between-server-and-client-using-cookies"},"Synchronizing state between server and client using cookies"),(0,o.kt)("p",null,"Another effective method for preventing hydration errors is synchronizing the state between the server and client using cookies, similar to the approach used with ",(0,o.kt)("a",{parentName:"p",href:"/docs/references/modules/client-hints#how-does-media-work"},"MediaStore from @tramvai/module-client-hints"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"import { createReducer, createEvent } from '@tramvai/state';\nimport { safeParseJSON } from '@tramvai/safe-strings';\n\nexport const change = createEvent('change');\nexport const Store = createReducer('state', {\n  counter: 0,\n  synchronized: false,\n}).on(change, (state, payload) => ({ ...state, ...payload }));\n\nconst Component: React.FC = () => {\n  const { synchronized, counter } = useStore(Store);\n\n  // Do not use data until it not synchronized\n  if (!synchronized) {\n    return <Skeleton />;\n  }\n\n  return <div>Counter is {counter}</div>;\n};\n\n// On the server side read client\n// state from cookies and synchronize it if exists\nprovide({\n  provide: commandLineListTokens.resolveUserDeps,\n  useFactory: ({ context, cookieManager }) =>\n    function syncStore() {\n      if (typeof window === 'undefined') {\n        const synchronizedDataFromClient = safeParseJSON(cookieManager.get(PERSISTENT_DATA) ?? '');\n\n        if (synchronizedDataFromClient !== null) {\n          context.dispatch(\n            change({\n              ...synchronizedDataFromClient,\n              synchronized: true,\n            })\n          );\n\n          return;\n        }\n      }\n    },\n  deps: {\n    context: CONTEXT_TOKEN,\n    cookieManager: COOKIE_MANAGER_TOKEN,\n  },\n});\n\n// On the client side, after hydration (clear stage)\n// write state to cookies and rerender\nprovide({\n  provide: commandLineListTokens.clear,\n  useFactory: ({ context, cookieManager }) =>\n    function saveDataToCookies() {\n      if (typeof window !== 'undefined') {\n        const data = getDataFromLocalStorage();\n\n        cookieManager.set({\n          name: PERSISTENT_DATA,\n          value: JSON.stringify(data),\n        });\n\n        context.dispatch(change(data));\n      }\n    },\n  deps: {\n    context: CONTEXT_TOKEN,\n    cookieManager: COOKIE_MANAGER_TOKEN,\n  },\n});\n")),(0,o.kt)("p",null,"The process involves the following steps:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Server and client does not use data for rendering until it's not synchronized;"),(0,o.kt)("li",{parentName:"ul"},"After hydration client reads data from local storage, save it to cookies and re-renders;"),(0,o.kt)("li",{parentName:"ul"},"If server receives synchronized data on subsequent requests it can use it to render.")),(0,o.kt)("p",null,"This method ensures that both client and server work with consistent and synchronized state data, minimizing the chances of hydration errors."),(0,o.kt)("h2",{id:"saving-state"},"Saving state"),(0,o.kt)("p",null,"To save state on the client side using ",(0,o.kt)("inlineCode",{parentName:"p"},"localStorage"),", you can use ",(0,o.kt)("a",{parentName:"p",href:"/docs/features/state-management#subscribe"},"subscribe")," method of the store. It's important to wrap the ",(0,o.kt)("inlineCode",{parentName:"p"},"localStorage")," operations in a ",(0,o.kt)("inlineCode",{parentName:"p"},"try/catch")," block to handle potential errors, such as when the user denies write access."),(0,o.kt)("p",null,"Worth noting that subscription should be set as soon as possible and no more than once. So, if you need kind of global synchronization use ",(0,o.kt)("inlineCode",{parentName:"p"},"customerStart")," stage:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"import { commandLineListTokens } from '@tramvai/core';\n\nexport const CounterStore = createReducer('counter', 0);\n\nprovide({\n  provide: commandLineListTokens.customerStart,\n  useValue: function persistState() {\n    CounterStore.subscribe((value) => {\n      try {\n        localStorage.setItem(key, JSON.stringify(value));\n      } catch (error) {\n        // Handle the error appropriately, or just ignore it\n      }\n    });\n  },\n});\n")))}p.isMDXComponent=!0}}]);