"use strict";(globalThis.webpackChunk=globalThis.webpackChunk||[]).push([[4982],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>d});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),p=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=p(e.components);return r.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),m=p(n),d=a,f=m["".concat(s,".").concat(d)]||m[d]||c[d]||o;return n?r.createElement(f,i(i({ref:t},u),{},{components:n})):r.createElement(f,i({ref:t},u))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var p=2;p<o;p++)i[p]=n[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},5162:(e,t,n)=>{n.d(t,{Z:()=>i});var r=n(7294),a=n(6010);const o="tabItem_Ymn6";function i({children:e,hidden:t,className:n}){return r.createElement("div",{role:"tabpanel",className:(0,a.Z)(o,n),hidden:t},e)}},4866:(e,t,n)=>{n.d(t,{Z:()=>T});var r=n(7462),a=n(7294),o=n(6010),i=n(2466),l=n(6550),s=n(1980),p=n(7392),u=n(12);function c(e){return function(e){return a.Children.map(e,(e=>{if((0,a.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))}(e).map((({props:{value:e,label:t,attributes:n,default:r}})=>({value:e,label:t,attributes:n,default:r})))}function m(e){const{values:t,children:n}=e;return(0,a.useMemo)((()=>{const e=t??c(n);return function(e){const t=(0,p.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function d({value:e,tabValues:t}){return t.some((t=>t.value===e))}function f({queryString:e=!1,groupId:t}){const n=(0,l.k6)(),r=function({queryString:e=!1,groupId:t}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:e,groupId:t});return[(0,s._X)(r),(0,a.useCallback)((e=>{if(!r)return;const t=new URLSearchParams(n.location.search);t.set(r,e),n.replace({...n.location,search:t.toString()})}),[r,n])]}function g(e){const{defaultValue:t,queryString:n=!1,groupId:r}=e,o=m(e),[i,l]=(0,a.useState)((()=>function({defaultValue:e,tabValues:t}){if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!d({value:e,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const n=t.find((e=>e.default))??t[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:t,tabValues:o}))),[s,p]=f({queryString:n,groupId:r}),[c,g]=function({groupId:e}){const t=function(e){return e?`docusaurus.tab.${e}`:null}(e),[n,r]=(0,u.Nk)(t);return[n,(0,a.useCallback)((e=>{t&&r.set(e)}),[t,r])]}({groupId:r}),v=(()=>{const e=s??c;return d({value:e,tabValues:o})?e:null})();(0,a.useLayoutEffect)((()=>{v&&l(v)}),[v]);return{selectedValue:i,selectValue:(0,a.useCallback)((e=>{if(!d({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);l(e),p(e),g(e)}),[p,g,o]),tabValues:o}}var v=n(2389);const h="tabList__CuJ",y="tabItem_LNqP";function k({className:e,block:t,selectedValue:n,selectValue:l,tabValues:s}){const p=[],{blockElementScrollPositionUntilNextRender:u}=(0,i.o5)(),c=e=>{const t=e.currentTarget,r=p.indexOf(t),a=s[r].value;a!==n&&(u(t),l(a))},m=e=>{let t=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const n=p.indexOf(e.currentTarget)+1;t=p[n]??p[0];break}case"ArrowLeft":{const n=p.indexOf(e.currentTarget)-1;t=p[n]??p[p.length-1];break}}t?.focus()};return a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":t},e)},s.map((({value:e,label:t,attributes:i})=>a.createElement("li",(0,r.Z)({role:"tab",tabIndex:n===e?0:-1,"aria-selected":n===e,key:e,ref:e=>p.push(e),onKeyDown:m,onClick:c},i,{className:(0,o.Z)("tabs__item",y,i?.className,{"tabs__item--active":n===e})}),t??e))))}function b({lazy:e,children:t,selectedValue:n}){if(t=Array.isArray(t)?t:[t],e){const e=t.find((e=>e.props.value===n));return e?(0,a.cloneElement)(e,{className:"margin-top--md"}):null}return a.createElement("div",{className:"margin-top--md"},t.map(((e,t)=>(0,a.cloneElement)(e,{key:t,hidden:e.props.value!==n}))))}function E(e){const t=g(e);return a.createElement("div",{className:(0,o.Z)("tabs-container",h)},a.createElement(k,(0,r.Z)({},e,t)),a.createElement(b,(0,r.Z)({},e,t)))}function T(e){const t=(0,v.Z)();return a.createElement(E,(0,r.Z)({key:String(t)},e))}},5342:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>s,default:()=>d,frontMatter:()=>l,metadata:()=>p,toc:()=>c});var r=n(7462),a=(n(7294),n(3905)),o=n(4866),i=n(5162);const l={id:"telemetry",title:"Telemetry"},s=void 0,p={unversionedId:"features/monitoring/telemetry",id:"features/monitoring/telemetry",title:"Telemetry",description:"Explanation",source:"@site/tmp-docs/03-features/014-monitoring/03-telemetry.md",sourceDirName:"03-features/014-monitoring",slug:"/features/monitoring/telemetry",permalink:"/docs/features/monitoring/telemetry",draft:!1,editUrl:"https://github.com/tramvaijs/tramvai/-/edit/master/docs/tmp-docs/03-features/014-monitoring/03-telemetry.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{id:"telemetry",title:"Telemetry"},sidebar:"sidebar",previous:{title:"Metrics",permalink:"/docs/features/monitoring/metrics"},next:{title:"Integrity",permalink:"/docs/features/build/integrity"}},u={},c=[{value:"Explanation",id:"explanation",level:2},{value:"Usage",id:"usage",level:2},{value:"Installation",id:"installation",level:3},{value:"Create spans",id:"create-spans",level:3},{value:"Export traces",id:"export-traces",level:3},{value:"Resource attributes",id:"resource-attributes",level:3},{value:"Active span",id:"active-span",level:3},{value:"Automatic instrumentation",id:"automatic-instrumentation",level:2},{value:"Server module",id:"server-module",level:3},{value:"Context propagation",id:"context-propagation",level:3},{value:"Pass <code>traceparent</code> context",id:"pass-traceparent-context",level:3},{value:"Server-side",id:"server-side",level:4},{value:"Client-side",id:"client-side",level:4},{value:"Logs correlation",id:"logs-correlation",level:3},{value:"Server-side",id:"server-side-1",level:4},{value:"Client-side",id:"client-side-1",level:4},{value:"Debug and testing",id:"debug-and-testing",level:2}],m={toc:c};function d({components:e,...t}){return(0,a.kt)("wrapper",(0,r.Z)({},m,t,{components:e,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"explanation"},"Explanation"),(0,a.kt)("p",null,"Telemetry and distributed tracing is a important part of complete application monitoring."),(0,a.kt)("p",null,"Tramvai provides a deep integration with ",(0,a.kt)("a",{parentName:"p",href:"https://opentelemetry.io/"},"OpenTelemetry")," Node.js SDK, with custom automatic instrumentation for internal Node.js modules and core Tramvai mechanisms."),(0,a.kt)("admonition",{type:"warning"},(0,a.kt)("p",{parentName:"admonition"},"Browser OpenTelemetry SDK is not supported yet, because of it limitations:"),(0,a.kt)("ul",{parentName:"admonition"},(0,a.kt)("li",{parentName:"ul"},"experimental status"),(0,a.kt)("li",{parentName:"ul"},"requires ",(0,a.kt)("inlineCode",{parentName:"li"},"zone.js")," dependency"),(0,a.kt)("li",{parentName:"ul"},"minimum 30+ kb gzip to bundle size and some performance overhead"))),(0,a.kt)("h2",{id:"usage"},"Usage"),(0,a.kt)("h3",{id:"installation"},"Installation"),(0,a.kt)("p",null,"You need to install ",(0,a.kt)("inlineCode",{parentName:"p"},"@tramvai/module-opentelemetry"),":"),(0,a.kt)(o.Z,{groupId:"npm2yarn",mdxType:"Tabs"},(0,a.kt)(i.Z,{value:"npm",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"npm i --save @tramvai/module-module-opentelemetry\n"))),(0,a.kt)(i.Z,{value:"yarn",label:"Yarn",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"yarn i --save @tramvai/module-module-opentelemetry\n# couldn't auto-convert command\n")))),(0,a.kt)("p",null,"Then connect to the project:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { createApp } from '@tramvai/core';\nimport { OpenTelemetryModule } from '@tramvai/module-opentelemetry';\n\ncreateApp({\n  name: 'tincoin',\n  modules: [OpenTelemetryModule],\n});\n")),(0,a.kt)("p",null,"This will enable OpenTelemetry with automatic instrumentation, and provide ",(0,a.kt)("inlineCode",{parentName:"p"},"Tracer")," into the application."),(0,a.kt)("h3",{id:"create-spans"},"Create spans"),(0,a.kt)("p",null,"Simplest way to wrap operation in span is to use ",(0,a.kt)("inlineCode",{parentName:"p"},"Tracer.trace")," method, e.g.:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { OPENTELEMETRY_TRACER_TOKEN } from '@tramvai/module-opentelemetry';\n\nconst provider = {\n  provide: commandLineListTokens.resolvePageDeps,\n  useFactory: ({ tracer, apiService }) => {\n    return async function getSmth() {\n      tracer?.trace('get-smth', async (span) => {\n        // set attribute to the span\n        span.setAttribute('key', 'value');\n\n        // span will be ended automatically after `apiService.get` method resolves or rejects\n        return apiService.get('/smth');\n      });\n    };\n  },\n  deps: {\n    // tracer exists only server-side\n    tracer: optional(OPENTELEMETRY_TRACER_TOKEN),\n    apiService: API_SERVICE_TOKEN,\n  },\n};\n")),(0,a.kt)("p",null,"For more flexibility methods ",(0,a.kt)("a",{parentName:"p",href:"https://open-telemetry.github.io/opentelemetry-js/interfaces/_opentelemetry_api.Tracer.html#startActiveSpan"},"Tracer.startActiveSpan")," and ",(0,a.kt)("a",{parentName:"p",href:"https://open-telemetry.github.io/opentelemetry-js/interfaces/_opentelemetry_api.Tracer.html#startSpan"},"Tracer.startSpan")," is available."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"Tracer.trace")," and other span creation methods calls can be nested, with ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/open-telemetry/opentelemetry-js/tree/main/packages/opentelemetry-context-async-hooks"},"automatic")," context propagation."),(0,a.kt)("h3",{id:"export-traces"},"Export traces"),(0,a.kt)("p",null,"For export traces to OpenTelemetry collector, you need to provide custom span processor and exporter with ",(0,a.kt)("inlineCode",{parentName:"p"},"OPENTELEMETRY_PROVIDER_SPAN_PROCESSOR_TOKEN")," token."),(0,a.kt)("p",null,"If you have a gRPC collector (e.g. Jaeger), library ",(0,a.kt)("inlineCode",{parentName:"p"},"@opentelemetry/exporter-trace-otlp-grpc")," can be used:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-grpc';\nimport { BatchSpanProcessor } from '@opentelemetry/sdk-trace-node';\nimport { OPENTELEMETRY_PROVIDER_SPAN_PROCESSOR_TOKEN } from '@tramvai/module-opentelemetry';\n\nconst provider = {\n  provide: OPENTELEMETRY_PROVIDER_SPAN_PROCESSOR_TOKEN,\n  useFactory: ({ envManager }) => {\n    const url = envManager.get('OTEL_GRPC_COLLECTOR_ENDPOINT');\n    const exporter = new OTLPTraceExporter({ url });\n\n    return new BatchSpanProcessor(exporter);\n  },\n  deps: {\n    envManager: ENV_MANAGER_TOKEN,\n  },\n};\n")),(0,a.kt)("h3",{id:"resource-attributes"},"Resource attributes"),(0,a.kt)("p",null,"If you need to extend ",(0,a.kt)("a",{parentName:"p",href:"https://opentelemetry.io/docs/concepts/resources/"},"resource")," attributes, use ",(0,a.kt)("inlineCode",{parentName:"p"},"OPENTELEMETRY_PROVIDER_RESOURCE_ATTRIBUTES_TOKEN")," token. Also, ",(0,a.kt)("inlineCode",{parentName:"p"},"@opentelemetry/semantic-conventions")," library contains some of attribute names."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { ATTR_SERVICE_NAME } from '@opentelemetry/semantic-conventions';\nimport { OPENTELEMETRY_PROVIDER_RESOURCE_ATTRIBUTES_TOKEN } from '@tramvai/module-opentelemetry';\n\nconst provider = {\n  provide: OPENTELEMETRY_PROVIDER_RESOURCE_ATTRIBUTES_TOKEN,\n  useFactory: ({ appInfo }) => {\n    return {\n      [ATTR_SERVICE_NAME]: appInfo.appName,\n    };\n  },\n  deps: {\n    appInfo: APP_INFO_TOKEN,\n  },\n};\n")),(0,a.kt)("h3",{id:"active-span"},"Active span"),(0,a.kt)("p",null,"If you need to set attributes to the active span, use ",(0,a.kt)("inlineCode",{parentName:"p"},"Tracer.getActiveSpan")," method:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"// tracer from OPENTELEMETRY_TRACER_TOKEN\nfunction doSmt({ tracer }) {\n  const span = tracer.getActiveSpan();\n\n  // span can be absent, for example in `init` or `listen` command line stages\n  span?.setAttribute('key', 'value');\n}\n")),(0,a.kt)("h2",{id:"automatic-instrumentation"},"Automatic instrumentation"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/@opentelemetry/instrumentation"},"OpenTelemetry instrumentation libraries")," is not supported, because of it limitations:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"instrumentations are registered before the module to instrument is require'ed"),(0,a.kt)("li",{parentName:"ul"},"modules are not included in a bundle")),(0,a.kt)("p",null,"Instead, module provides custom instrumentation for all significant cases:"),(0,a.kt)("h3",{id:"server-module"},"Server module"),(0,a.kt)("p",null,"All incoming requests are automatically wrapped in ",(0,a.kt)("strong",{parentName:"p"},"root span"),", where current request and response parameters will be set (path, method, status code, error)."),(0,a.kt)("p",null,"Naming and attributes follow ",(0,a.kt)("a",{parentName:"p",href:"https://opentelemetry.io/docs/specs/semconv/http/http-spans/"},"semantic conventions"),"."),(0,a.kt)("h3",{id:"context-propagation"},"Context propagation"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"OpenTelemetryModule")," provides ",(0,a.kt)("a",{parentName:"p",href:"https://opentelemetry.io/docs/languages/js/propagation/"},"context propagation")," for incoming and outgoing requests."),(0,a.kt)("h3",{id:"pass-traceparent-context"},"Pass ",(0,a.kt)("inlineCode",{parentName:"h3"},"traceparent")," context"),(0,a.kt)("h4",{id:"server-side"},"Server-side"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"OpenTelemetryModule")," inject ",(0,a.kt)("inlineCode",{parentName:"p"},"traceparent")," header to all external API requests via Tramvai ",(0,a.kt)("a",{parentName:"p",href:"/docs/features/data-fetching/http-client"},"HTTP Clients"),"."),(0,a.kt)("p",null,"On the server-side module includes ",(0,a.kt)("inlineCode",{parentName:"p"},"traceparent")," meta-tag in resulting html according to ",(0,a.kt)("a",{parentName:"p",href:"https://www.w3.org/TR/trace-context/"},"W3C")," format. Also, it bypasses ",(0,a.kt)("inlineCode",{parentName:"p"},"traceparent")," ",(0,a.kt)("a",{parentName:"p",href:"https://www.w3.org/TR/trace-context/#traceparent-header"},"header")," to external APIs."),(0,a.kt)("h4",{id:"client-side"},"Client-side"),(0,a.kt)("p",null,"On the client-side, if ",(0,a.kt)("inlineCode",{parentName:"p"},"traceparent")," meta-tag exists need to be used, you can extract in at follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import { extractTraceparentHeader } from '@tramvai/module-opentelemetry';\n\nconst extractTraceparent = (): string | undefined => {\n  const traceparent = extractTraceparentHeader();\n\n  const [version, traceId, spanId, sampled] = tags[0].content.split('-');\n\n  return traceId;\n};\n")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"traceparent")," header is not added to outgoing requests in a browser context, because of it will connect current SSR trace and all corresponding backend's traces for current browser session, which can leads to huge traces and inefficient debugging."),(0,a.kt)("h3",{id:"logs-correlation"},"Logs correlation"),(0,a.kt)("h4",{id:"server-side-1"},"Server-side"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"OpenTelemetryModule")," inject context for ",(0,a.kt)("a",{parentName:"p",href:"https://opentelemetry.io/docs/specs/otel/logs/#log-correlation"},"logs correlation"),"."),(0,a.kt)("p",null,"All application logs will be extended with current span and trace ids in ",(0,a.kt)("inlineCode",{parentName:"p"},"spanId")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"traceId")," properties."),(0,a.kt)("h4",{id:"client-side-1"},"Client-side"),(0,a.kt)("p",null,"In a browser context, ",(0,a.kt)("inlineCode",{parentName:"p"},"spanId")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"traceId")," properties is not added to client logs, because of it will connect current SSR logs and all corresponding backend's logs for current browser session, which can leads to huge amount of logs and inefficient debugging."),(0,a.kt)("h2",{id:"debug-and-testing"},"Debug and testing"),(0,a.kt)("p",null,"By default, in ",(0,a.kt)("inlineCode",{parentName:"p"},"development")," mode ",(0,a.kt)("a",{parentName:"p",href:"https://open-telemetry.github.io/opentelemetry-js/classes/_opentelemetry_sdk_trace_base.ConsoleSpanExporter.html"},"ConsoleSpanExporter")," is used, which prints all spans to the console."),(0,a.kt)("p",null,"For testing purposes, you can use ",(0,a.kt)("a",{parentName:"p",href:"https://open-telemetry.github.io/opentelemetry-js/classes/_opentelemetry_sdk_trace_base.InMemorySpanExporter.html"},"InMemorySpanExporter"),"."))}d.isMDXComponent=!0}}]);