"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[1718],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var d=a.createContext({}),l=function(e){var t=a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=l(e.components);return a.createElement(d.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,d=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=l(n),m=r,f=u["".concat(d,".").concat(m)]||u[m]||c[m]||i;return n?a.createElement(f,o(o({ref:t},p),{},{components:n})):a.createElement(f,o({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=u;var s={};for(var d in t)hasOwnProperty.call(t,d)&&(s[d]=t[d]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var l=2;l<i;l++)o[l]=n[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},3832:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>d,default:()=>m,frontMatter:()=>s,metadata:()=>l,toc:()=>c});var a=n(7462),r=n(3366),i=(n(7294),n(3905)),o=["components"],s={id:"streaming-data",title:"Streaming Data"},d=void 0,l={unversionedId:"features/data-fetching/streaming-data",id:"features/data-fetching/streaming-data",title:"Streaming Data",description:"Experimental feature",source:"@site/tmp-docs/03-features/09-data-fetching/06-streaming-data.md",sourceDirName:"03-features/09-data-fetching",slug:"/features/data-fetching/streaming-data",permalink:"/docs/features/data-fetching/streaming-data",draft:!1,editUrl:"https://github.com/tramvaijs/tramvai/-/edit/master/docs/get-started/overview.md/tmp-docs/03-features/09-data-fetching/06-streaming-data.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{id:"streaming-data",title:"Streaming Data"},sidebar:"sidebar",previous:{title:"React Query",permalink:"/docs/features/data-fetching/react-query"},next:{title:"Server-Side Rendering",permalink:"/docs/features/rendering/ssr"}},p={},c=[{value:"Explanation",id:"explanation",level:2},{value:"Deferred Data Fetching",id:"deferred-data-fetching",level:3},{value:"Usage",id:"usage",level:2},{value:"Prerequisites",id:"prerequisites",level:3},{value:"Deferred Actions",id:"deferred-actions",level:3},{value:"How-to",id:"how-to",level:2},{value:"Use deferred actions with route dynamic parameters",id:"use-deferred-actions-with-route-dynamic-parameters",level:3},{value:"Use tramvai lazy inside Await component",id:"use-tramvai-lazy-inside-await-component",level:3},{value:"Use deferred actions data outside React components",id:"use-deferred-actions-data-outside-react-components",level:3}],u={toc:c};function m(e){var t=e.components,s=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},u,s,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"Experimental feature")),(0,i.kt)("h2",{id:"explanation"},"Explanation"),(0,i.kt)("p",null,"Imagine that you have a slow API call that returns a large amount of data, which is important to display to the user fast as possible, e.g. flight tickets or hotels search results."),(0,i.kt)("p",null,"Waiting for this data at server-side is not optimal, because user will see a blank page for a seconds. Usually, you will run this API call on the client-side, and results will be displayed very later, after this steps:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"page response finished"),(0,i.kt)("li",{parentName:"ul"},"static assets are loaded (JS, CSS)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/docs/features/rendering/hydration"},"hydration")," is completed")),(0,i.kt)("p",null,"This problem and possible solution is perfectly illustrated in the ",(0,i.kt)("a",{parentName:"p",href:"https://remix.run/docs/en/1.19.3/guides/streaming"},"remix.run")," documentation:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Diagram",src:n(2313).Z,width:"3297",height:"2039"})),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"By the way, this feature is heavily inspired by the ",(0,i.kt)("inlineCode",{parentName:"p"},"Remix")," framework ",(0,i.kt)("inlineCode",{parentName:"p"},"defer + Await")," API and new ",(0,i.kt)("inlineCode",{parentName:"p"},"React 18")," streaming capabilities!")),(0,i.kt)("p",null,"So, what is the Deferred Data Fetching and how it can solve the problem?"),(0,i.kt)("p",null,"Thanks to the ",(0,i.kt)("inlineCode",{parentName:"p"},"renderToPipeableStream")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Suspense")," API's, and ",(0,i.kt)("a",{parentName:"p",href:"https://www.patterns.dev/posts/react-selective-hydration/"},"Selective Hydration"),", we have the ability to run API call on the server-side without waiting for it before send application shell + loading indicator to the client. At client-side, loading indicator will be replaced when API call is finished, and results will be displayed and hydrated significantly faster."),(0,i.kt)("h3",{id:"deferred-data-fetching"},"Deferred Data Fetching"),(0,i.kt)("p",null,"For deferred data fetching, you need to use usual ",(0,i.kt)("inlineCode",{parentName:"p"},"tramvai")," ",(0,i.kt)("a",{parentName:"p",href:"/docs/features/data-fetching/action"},"Actions")," with ",(0,i.kt)("inlineCode",{parentName:"p"},"deferred: true")," property, we call it ",(0,i.kt)("a",{parentName:"p",href:"#deferred-actions"},"Deferred Actions"),"."),(0,i.kt)("p",null,"Main difference between regular Actions is that Deferred Actions are executed on the server-side without ",(0,i.kt)("a",{parentName:"p",href:"/docs/features/data-fetching/action#execution-deadline"},"timeout"),", and not blocking first page response (application shell)."),(0,i.kt)("p",null,'For every Deferred Actions will be created a promise, which status will be "teleported" to the client-side after it is resolved (or rejected) at server-side.'),(0,i.kt)("p",null,"With new ",(0,i.kt)("inlineCode",{parentName:"p"},"Await")," component, this unresolved promise will be thrown to nearest ",(0,i.kt)("inlineCode",{parentName:"p"},"Suspense")," boundary, and ",(0,i.kt)("inlineCode",{parentName:"p"},"fallback")," will be rendered and sended to the client with application shell."),(0,i.kt)("p",null,"After promise resolve or reject, React will send code to render suspended ",(0,i.kt)("inlineCode",{parentName:"p"},"Await")," component into the response stream, and ",(0,i.kt)("inlineCode",{parentName:"p"},"tramvai")," will send promise payload and status to the client."),(0,i.kt)("p",null,"At client side, application shell hydration will be started as soon as possible. For suspended ",(0,i.kt)("inlineCode",{parentName:"p"},"Await")," component, hydration will be delayed until the promise will be resolved or rejected."),(0,i.kt)("h2",{id:"usage"},"Usage"),(0,i.kt)("h3",{id:"prerequisites"},"Prerequisites"),(0,i.kt)("p",null,"For this feature to work, you need to install ",(0,i.kt)("inlineCode",{parentName:"p"},"react>=18")," version and enable ",(0,i.kt)("a",{parentName:"p",href:"/docs/features/rendering/streaming"},"streaming rendering"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { REACT_SERVER_RENDER_MODE } from '@tramvai/tokens-render';\n\nconst provider = provide({\n  provide: REACT_SERVER_RENDER_MODE,\n  useValue: 'streaming',\n});\n")),(0,i.kt)("h3",{id:"deferred-actions"},"Deferred Actions"),(0,i.kt)("p",null,"\u231b First, create a ",(0,i.kt)("a",{parentName:"p",href:"/docs/features/data-fetching/action#page-actions"},"page actions")," with new ",(0,i.kt)("inlineCode",{parentName:"p"},"deferred")," property:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { declareAction } from '@tramvai/core';\n\nconst deferredAction = declareAction({\n  name: 'deferred',\n  // highlight-next-line\n  deferred: true,\n  fn() {\n    return this.deps.httpClient.get('/slow-endpoint');\n  },\n  deps: {\n    httpClient: HTTP_CLIENT,\n  },\n});\n")),(0,i.kt)("p",null,"\u231b Then, provide this action to page component ",(0,i.kt)("inlineCode",{parentName:"p"},"actions"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"Await")," component. Data will be available in ",(0,i.kt)("inlineCode",{parentName:"p"},"Await")," children function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"import { PageComponent } from '@tramvai/react';\n// highlight-next-line\nimport { Await } from '@tramvai/module-common';\n\nconst Page: PageComponent = () => {\n  return (\n    <>\n      <Header />\n      // highlight-start\n      <Suspense fallback={<div>Loading...</div>}>\n        <Await action={deferredAction}>\n          {(data) => <div>Result: {JSON.stringify(data)}</div>}\n        </Await>\n      </Suspense>\n      // highlight-end\n      <Footer />\n    </>\n  )\n};\n\n// highlight-next-line\nPage.actions = [deferredAction];\n\nexport default Page;\n")),(0,i.kt)("p",null,"After that, at page initia load (or with disabled JS) you will see header, footer and ",(0,i.kt)("inlineCode",{parentName:"p"},"Loading...")," fallback. After API response, data will be teleported to client, and you will see the ",(0,i.kt)("inlineCode",{parentName:"p"},"Result: ...")," instead of fallback."),(0,i.kt)("p",null,"You can change ",(0,i.kt)("inlineCode",{parentName:"p"},"deferred: true")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"conditions: { onlyBrowser: true }")," and compare how slower results render will be."),(0,i.kt)("h2",{id:"how-to"},"How-to"),(0,i.kt)("h3",{id:"use-deferred-actions-with-route-dynamic-parameters"},"Use deferred actions with route dynamic parameters"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/docs/features/routing/working-with-url#route-params"},"Page with dynamic parameters")," it is a common case, and have full Deferred Actions support with important nuance - you need to ",(0,i.kt)("strong",{parentName:"p"},"manually subscribe")," to the route changes in your component where ",(0,i.kt)("inlineCode",{parentName:"p"},"Await")," is used."),(0,i.kt)("p",null,"Let's update our previous example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"import { declareAction } from '@tramvai/core';\nimport { PageComponent } from '@tramvai/react';\nimport { Await } from '@tramvai/module-common';\n    // highlight-next-line\nimport { useRoute } from '@tinkoff/router';\n\nconst deferredAction = declareAction({\n  name: 'deferred',\n  deferred: true,\n  fn() {\n    // highlight-next-line\n    const id = this.deps.pageService.getCurrentRoute().params.id;\n\n    return this.deps.httpClient.get('/slow-endpoint', { query: { id } });\n  },\n  deps: {\n    httpClient: HTTP_CLIENT,\n    pageService: PAGE_SERVICE_TOKEN,\n  },\n});\n\nconst Page: PageComponent = () => {\n  // highlight-next-line\n  const { params } = useRoute();\n\n  return (\n    <>\n      <Header />\n      <Suspense fallback={<div>Loading...</div>} key={params.id}>\n        <Await action={deferredAction}>\n          {(data) => <div>Result: {JSON.stringify(data)}</div>}\n        </Await>\n      </Suspense>\n      <Footer />\n    </>\n  )\n};\n\nPage.actions = [deferredAction];\n\nexport default Page;\n")),(0,i.kt)("p",null,"Because of the ",(0,i.kt)("inlineCode",{parentName:"p"},"useRoute")," hook, ",(0,i.kt)("inlineCode",{parentName:"p"},"Await")," will use correct Deferred Action for current route at first load and after SPA-transitions."),(0,i.kt)("h3",{id:"use-tramvai-lazy-inside-await-component"},"Use tramvai lazy inside Await component"),(0,i.kt)("p",null,"Deferred Actions have full support with ",(0,i.kt)("inlineCode",{parentName:"p"},"tramvai")," ",(0,i.kt)("inlineCode",{parentName:"p"},"lazy"),", sync JS and CSS tags for dynamic import will be injected into the response stream after deferred promise resolve, and will be loaded and parsed before suspended component hydration - no content shifting or hydration errors! Simple example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"import { lazy } from '@tramvai/react';\n\nconst LazyDataCmp = lazy(() => import('~components/DataCmp'));\n\nconst RootCmp = () => {\n  return (\n    <>\n      <Suspense fallback={<div>Loading...</div>}>\n        <Await action={deferredAction}>\n          {(data) => <LazyDataCmp data={data} />}\n        </Await>\n      </Suspense>\n    </>\n  )\n};\n")),(0,i.kt)("h3",{id:"use-deferred-actions-data-outside-react-components"},"Use deferred actions data outside React components"),(0,i.kt)("p",null,"Deferred Actions + ",(0,i.kt)("inlineCode",{parentName:"p"},"Suspense")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Await")," has one important limitation - deferred data is used only inside React components, and you can't dispatch deferred data to the reducer at server-side in this actions, because only initial state will be passed to client with app shell."),(0,i.kt)("p",null,"Meaning this ",(0,i.kt)("strong",{parentName:"p"},"will not")," work:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const deferredAction = declareAction({\n  name: 'deferred',\n  deferred: true,\n  async fn() {\n    const { payload } = await this.deps.httpClient.get('/slow-endpoint');\n\n    // it is too late, store initial state already sent to client\n    // highlight-next-line\n    this.dispatch(slowEndpointReducerSuccessEvent(payload));\n  },\n  deps: {\n    httpClient: HTTP_CLIENT,\n  },\n});\n")),(0,i.kt)("p",null,"As a workaround, you can wait Deferred Actions manually at client-side in usual client-only action. All deferred actions available in ",(0,i.kt)("inlineCode",{parentName:"p"},"DEFERRED_ACTIONS_MAP_TOKEN"),". Let's update our first example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// deferredAction without any changes\n\n// create a reducer to store deferred data\nconst DeferredState = createReducer({\n  name: 'deferredState',\n  initialState: { status: 'pending' },\n  events: {\n    success: (state, payload) => ({ status: 'success', payload }),\n  },\n});\n\n// create a browser-only action for data syncronization\nconst deferredStateSyncAction = declareAction({\n  name: 'deferredStateSync',\n  async fn() {\n    // use deferred action name as a key \n    const deferred = this.deps.deferredActionsMap.get(\n      deferredAction.name\n    );\n\n    // wait for deferred promise (in real-world case don't forget to handle error case)\n    await deferred!.promise;\n\n    // sync deferred data with our new store\n    this.dispatch(\n      deferredState.events.success(deferred!.resolveData)\n    );\n  },\n  deps: {\n    deferredActionsMap: DEFERRED_ACTIONS_MAP_TOKEN,\n  },\n  conditions: {\n    onlyBrowser: true,\n  },\n});\n\nconst Page: PageComponent = () => {\n  const state = useStore(deferredState);\n\n  return (\n    <>\n      <h1>Deferred State Page</h1>\n      {state.status === 'pending' ? (\n        <div>Loading...</div>\n      ) : (\n        <div>{`Response: ${state.payload.data}`}</div>\n      )}\n    </>\n  );\n};\n\nPage.reducers = [deferredState];\n\nPage.actions = [deferredAction, deferredStateSyncAction];\n\nexport default Page;\n")),(0,i.kt)("p",null,"Without ",(0,i.kt)("inlineCode",{parentName:"p"},"Suspense")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Await"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"tramvai")," will stream only deferred data to the client, for React all this component will be rendered as app shell, at first HTML chunk."))}m.isMDXComponent=!0},2313:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/data-fetching-client-vs-streaming-dc368950610db318c6ce360ee6200abe.svg"}}]);